// Contains constructors for iterators that generate values
package iter

import (
	"sync"
	"sync/atomic"
)

// Function Sequence returns a sequence iterator.
// Iterator will return ints starting from start value with a given step.
func Sequence(start, step int) Iterator[int] {
	value := start - step
	return func() (int, error) {
		value += step
		return value, nil
	}
}

// Function SequenceSafe returns a thread safe sequence iterator.
// Iterator will return ints starting from start value with a given step.
func SequenceSafe(start, step int) Iterator[int] {
	value := &atomic.Int64{}
	value.Add(int64(start - step))
	step64 := int64(step)
	return func() (int, error) {
		v := value.Add(step64)
		return int(v), nil
	}
}

// Function Generator returns a thread safe generating iterator.
// Iterator will return values generated by given function.
func Generator[T any](generator func() T) Iterator[T] {
	return func() (T, error) {
		return generator(), nil
	}
}

// Function Repeat returns a thread safe repeating iterator.
// Iterator returns given value indefinitely.
func Repeat[T any](value T) Iterator[T] {
	return func() (T, error) {
		return value, nil
	}
}

// Function Cycle returns an iterator that cycles
// through given set of values.
func Cycle[T any](values ...T) Iterator[T] {
	var cursor int
	l := len(values)
	return func() (T, error) {
		if l == 0 {
			var empty T
			return empty, ErrStopIt
		}
		v := values[cursor]
		cursor++
		if cursor >= l {
			cursor %= l
		}
		return v, nil
	}
}

// Function CycleSafe returns a thread safe iterator that cycles
// through given set of values.
func CycleSafe[T any](values ...T) Iterator[T] {
	var cursor int
	l := len(values)
	var mutex sync.Mutex

	return func() (T, error) {
		mutex.Lock()
		defer mutex.Unlock()
		if l == 0 {
			var empty T
			return empty, ErrStopIt
		}
		v := values[cursor]
		cursor++
		if cursor >= l {
			cursor %= l
		}
		return v, nil
	}
}
